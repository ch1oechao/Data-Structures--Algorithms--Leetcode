# Graph 

图是网络结构的抽象模型

图是一组由边连接的节点(或顶点)

一个图 G = (V, E) 有以下元素组成

- V: 一组顶点
- E: 一组边，连接 V 中的顶点

---

由一条边连接在一起的顶点称为相邻顶点

一个顶点的度是其相邻顶点的数量

路径是顶点 v1, v2, ..., vk 的一个连续的序列 其中 vi 和 vi+1 是相邻的

简单路径要求不包含重复的顶点 环也是一个简单路径

---

### 有向图和无向图

图可以是无向的(边没有方向)或是有向的

如果图中两个顶点间在双向都存在路径，则该图是强连通的

图还可以是未加权的或是加权的

### 图的表示

- **邻接矩阵**

    图最常见的实现是邻接矩阵

    每个节点都和一个整数相关联 该整数将作为数组的索引

    用一个二维数组表示顶点之间的连接

    如果索引为 i 的节点和索引为 j 的节点相邻 则 array[i][j] === 1 否则 array[i][j] === 0

- **邻接表**

    邻接表由图中每个顶点的相邻顶点列表所组成

- **关联矩阵**

    在关联矩阵中 矩阵的行表示顶点 列表示边

    用一个二维数组表示两者之间的连通性

    如果顶点 v 是边 e 的入射点 则 array[v][e] === 1 否则 array[v][e] === 0

    关联矩阵通常用于边的数量比顶点多的情况下，以节省空间和内存


### 图的遍历

图遍历可以用来寻找特定的顶点或寻找两个顶点之间的路径 检查图是否连通 检查图是否含有环

- **广度优先搜索** (Breadth-First Search, BFS)

    数据结构: 栈

    通过将顶点存入栈中 顶点是沿着路径被探索的 存在新的相邻顶点就去访问

- **深度优先搜索** (Depth-First Search, DFS)

    数据结构: 队列

    通过将顶点存入队列中 最先乳队列的顶点先被探索

使用颜色来标注顶点的访问状态

- 白色

     表示该顶点还没有被访问

- 灰色

    表示该顶点被访问过 但未被探索过

- 黑色

    表示该顶点被访问且被完全探索过


### 广度优先搜索

从指定的第一个顶点开始遍历图 先访问其所有相邻点 

以下是从顶点 v 开始的广度优先搜索算法所遵循的步骤

(1) 创建一个队列 Q

(2) 将 v 标注为被发现的 (灰色) 并将 v 入队列 Q

(3) 如果 Q 非空 则运行以下步骤:

    (a) 将 u 从 q 中出队列
    (b) 将标注 u 为被发现的 (灰色)
    (c) 将 u 所有违背访问过的邻点 (白色) 入队列
    (d) 将 u 标注为已被探索的 (黑色)

- 使用 BFS 寻找最短路径

    给定一个图 G 和源顶点 v 找出对每一个顶点 u 求 u 和 v 之间最短路径的距离

    对于给定顶点 v 广度优先算法会访问所有与其距离为1的顶点 接着是距离为2的顶点 以此类推

    - 从 v 到 u 的距离 d[u]
    - 前溯点 pred[u] 用来推导出从 v 到其他每个顶点 u 的最短路径

### 深度优先搜索

深度优先搜索算法将会从第一个指定的顶点开始遍历图 沿着路径直到这条路径最后一个顶点被访问了 

接着原路退回并探索下一条路径 

它是先深度后广度地访问顶点

以下是从顶点 v 开始的深度优先搜索算法所遵循的步骤

(1) 标注 v 为被发现的 (灰色)

(2) 对于 v 的所有未访问的邻点 w
    
    (a) 访问顶点 w

(3) 标注 v 为已被探索的 (黑色)

- 探索深度优先算法

    - 顶点 u 的发现时间 d[u]
    - 当顶点 u 被标注为黑色时， u 的完成探索时间 f[u]
    - 顶点 u 的前溯点 p[u]

    
